<!DOCTYPE html>
<html lang="en">
<html>
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dotgrid</title>
  </head>
  <body>
    <script>
'use strict'
function Acels (client) {
  this.all = {}
  this.roles = {}
  this.pipe = null
  this.install = (host = window) => {
    host.addEventListener('keydown', this.onKeyDown, false)
    host.addEventListener('keyup', this.onKeyUp, false)
  }
  this.set = (cat, name, accelerator, downfn, upfn) => {
    if (this.all[accelerator]) { console.warn('Acels', `Trying to overwrite ${this.all[accelerator].name}, with ${name}.`) }
    this.all[accelerator] = { cat, name, downfn, upfn, accelerator }
  }
  this.add = (cat, role) => {
    this.all[':' + role] = { cat, name: role, role }
  }
  this.get = (accelerator) => {
    return this.all[accelerator]
  }
  this.sort = () => {
    const h = {}
    for (const item of Object.values(this.all)) {
      if (!h[item.cat]) { h[item.cat] = [] }
      h[item.cat].push(item)
    }
    return h
  }
  this.convert = (event) => {
    const accelerator = event.key === ' ' ? 'Space' : event.key.substr(0, 1).toUpperCase() + event.key.substr(1)
    if ((event.ctrlKey || event.metaKey) && event.shiftKey) {
      return `CmdOrCtrl+Shift+${accelerator}`
    }
    if (event.shiftKey && event.key.toUpperCase() !== event.key) {
      return `Shift+${accelerator}`
    }
    if (event.altKey && event.key.length !== 1) {
      return `Alt+${accelerator}`
    }
    if (event.ctrlKey || event.metaKey) {
      return `CmdOrCtrl+${accelerator}`
    }
    return accelerator
  }
  this.pipe = (obj) => {
    this.pipe = obj
  }
  this.onKeyDown = (e) => {
    const target = this.get(this.convert(e))
    if (!target || !target.downfn) { return this.pipe ? this.pipe.onKeyDown(e) : null }
    target.downfn()
    e.preventDefault()
  }
  this.onKeyUp = (e) => {
    const target = this.get(this.convert(e))
    if (!target || !target.upfn) { return this.pipe ? this.pipe.onKeyUp(e) : null }
    target.upfn()
    e.preventDefault()
  }
  this.toMarkdown = () => {
    const cats = this.sort()
    let text = ''
    for (const cat in cats) {
      text += `\n### ${cat}\n\n`
      for (const item of cats[cat]) {
        text += item.accelerator ? `- \`${item.accelerator}\`: ${item.name}\n` : ''
      }
    }
    return text.trim()
  }
  this.toString = () => {
    const cats = this.sort()
    let text = ''
    for (const cat in cats) {
      for (const item of cats[cat]) {
        text += item.accelerator ? `${cat}: ${item.name} | ${item.accelerator}\n` : ''
      }
    }
    return text.trim()
  }
}
'use strict'
function History () {
  this.index = 0
  this.a = []
  this.clear = function () {
    this.a = []
    this.index = 0
  }
  this.push = function (data) {
    if (this.index < this.a.length - 1) {
      this.fork()
    }
    this.index = this.a.length
    this.a = this.a.slice(0, this.index)
    this.a.push(copy(data))
    if (this.a.length > 20) {
      this.a.shift()
    }
  }
  this.fork = function () {
    this.a = this.a.slice(0, this.index + 1)
  }
  this.pop = function () {
    return this.a.pop()
  }
  this.prev = function () {
    this.index = clamp(this.index - 1, 0, this.a.length - 1)
    return copy(this.a[this.index])
  }
  this.next = function () {
    this.index = clamp(this.index + 1, 0, this.a.length - 1)
    return copy(this.a[this.index])
  }
  function copy (data) { return data ? JSON.parse(JSON.stringify(data)) : [] }
  function clamp (v, min, max) { return v < min ? min : v > max ? max : v }
}
'use strict'
function Source (client) {
  this.cache = {}
  this.install = () => {
  }
  this.start = () => {
    this.new()
  }
  this.new = () => {
    console.log('Source', 'New file..')
    this.cache = {}
  }
  this.open = (ext, callback, store = false) => {
    console.log('Source', 'Open file..')
    const input = document.createElement('input')
    input.type = 'file'
    input.onchange = (e) => {
      const file = e.target.files[0]
      if (file.name.indexOf('.' + ext) < 0) { console.warn('Source', `Skipped ${file.name}`); return }
      this.read(file, callback, store)
    }
    input.click()
  }
  this.load = (ext, callback) => {
    console.log('Source', 'Load files..')
    const input = document.createElement('input')
    input.type = 'file'
    input.setAttribute('multiple', 'multiple')
    input.onchange = (e) => {
      for (const file of e.target.files) {
        if (file.name.indexOf('.' + ext) < 0) { console.warn('Source', `Skipped ${file.name}`); continue }
        this.read(file, this.store)
      }
    }
    input.click()
  }
  this.store = (file, content) => {
    console.info('Source', 'Stored ' + file.name)
    this.cache[file.name] = content
  }
  this.save = (name, content, type = 'text/plain', callback) => {
    this.saveAs(name, content, type, callback)
  }
  this.saveAs = (name, ext, content, type = 'text/plain', callback) => {
    console.log('Source', 'Save new file..')
    this.write(name, ext, content, type, callback)
  }
  this.read = (file, callback, store = false) => {
    const reader = new FileReader()
    reader.onload = (event) => {
      const res = event.target.result
      if (callback) { callback(file, res) }
      if (store) { this.store(file, res) }
    }
    reader.readAsText(file, 'UTF-8')
  }
  this.write = (name, ext, content, type, settings = 'charset=utf-8') => {
    const link = document.createElement('a')
    link.setAttribute('download', `${name}-${timestamp()}.${ext}`)
    if (type === 'image/png' || type === 'image/jpeg') {
      link.setAttribute('href', content)
    } else {
      link.setAttribute('href', 'data:' + type + ';' + settings + ',' + encodeURIComponent(content))
    }
    link.dispatchEvent(new MouseEvent('click', { bubbles: true, cancelable: true, view: window }))
  }
  function timestamp (d = new Date(), e = new Date(d)) {
    return `${arvelie()}-${neralie()}`
  }
  function arvelie (date = new Date()) {
    const start = new Date(date.getFullYear(), 0, 0)
    const diff = (date - start) + ((start.getTimezoneOffset() - date.getTimezoneOffset()) * 60 * 1000)
    const doty = Math.floor(diff / 86400000) - 1
    const y = date.getFullYear().toString().substr(2, 2)
    const m = doty === 364 || doty === 365 ? '+' : String.fromCharCode(97 + Math.floor(doty / 14)).toUpperCase()
    const d = `${(doty === 365 ? 1 : doty === 366 ? 2 : (doty % 14)) + 1}`.padStart(2, '0')
    return `${y}${m}${d}`
  }
  function neralie (d = new Date(), e = new Date(d)) {
    const ms = e - d.setHours(0, 0, 0, 0)
    return (ms / 8640 / 10000).toFixed(6).substr(2, 6)
  }
}
'use strict'
function Theme (client) {
  this.el = document.createElement('style')
  this.el.type = 'text/css'
  this.active = {}
  this.default = {
    background: '#eeeeee',
    f_high: '#0a0a0a',
    f_med: '#4a4a4a',
    f_low: '#6a6a6a',
    f_inv: '#111111',
    b_high: '#a1a1a1',
    b_med: '#c1c1c1',
    b_low: '#ffffff',
    b_inv: '#ffb545'
  }
  this.onLoad = () => {}
  this.install = (host = document.body) => {
    window.addEventListener('dragover', this.drag)
    window.addEventListener('drop', this.drop)
    host.appendChild(this.el)
  }
  this.start = () => {
    console.log('Theme', 'Starting..')
    if (isJson(localStorage.theme)) {
      const storage = JSON.parse(localStorage.theme)
      if (isValid(storage)) {
        console.log('Theme', 'Loading theme in localStorage..')
        this.load(storage)
        return
      }
    }
    this.load(this.default)
  }
  this.open = () => {
    console.log('Theme', 'Open theme..')
    const input = document.createElement('input')
    input.type = 'file'
    input.onchange = (e) => {
      this.read(e.target.files[0], this.load)
    }
    input.click()
  }
  this.load = (data) => {
    const theme = this.parse(data)
    if (!isValid(theme)) { console.warn('Theme', 'Invalid format'); return }
    console.log('Theme', 'Loaded theme!')
    this.el.innerHTML = `:root { 
      --background: ${theme.background}; 
      --f_high: ${theme.f_high}; 
      --f_med: ${theme.f_med}; 
      --f_low: ${theme.f_low}; 
      --f_inv: ${theme.f_inv}; 
      --b_high: ${theme.b_high}; 
      --b_med: ${theme.b_med}; 
      --b_low: ${theme.b_low}; 
      --b_inv: ${theme.b_inv};
    }`
    localStorage.setItem('theme', JSON.stringify(theme))
    this.active = theme
    if (this.onLoad) {
      this.onLoad(data)
    }
  }
  this.reset = () => {
    this.load(this.default)
  }
  this.set = (key, val) => {
    if (!val) { return }
    const hex = (`${val}`.substr(0, 1) !== '#' ? '#' : '') + `${val}`
    if (!isColor(hex)) { console.warn('Theme', `${hex} is not a valid color.`); return }
    this.active[key] = hex
  }
  this.read = (key) => {
    return this.active[key]
  }
  this.parse = (any) => {
    if (isValid(any)) { return any }
    if (isJson(any)) { return JSON.parse(any) }
    if (isHtml(any)) { return extract(any) }
  }
  this.drag = (e) => {
    e.stopPropagation()
    e.preventDefault()
    e.dataTransfer.dropEffect = 'copy'
  }
  this.drop = (e) => {
    e.preventDefault()
    const file = e.dataTransfer.files[0]
    if (file.name.indexOf('.svg') > -1) {
      this.read(file, this.load)
    }
    e.stopPropagation()
  }
  this.read = (file, callback) => {
    const reader = new FileReader()
    reader.onload = (event) => {
      callback(event.target.result)
    }
    reader.readAsText(file, 'UTF-8')
  }
  function extract (xml) {
    const svg = new DOMParser().parseFromString(xml, 'text/xml')
    try {
      return {
        background: svg.getElementById('background').getAttribute('fill'),
        f_high: svg.getElementById('f_high').getAttribute('fill'),
        f_med: svg.getElementById('f_med').getAttribute('fill'),
        f_low: svg.getElementById('f_low').getAttribute('fill'),
        f_inv: svg.getElementById('f_inv').getAttribute('fill'),
        b_high: svg.getElementById('b_high').getAttribute('fill'),
        b_med: svg.getElementById('b_med').getAttribute('fill'),
        b_low: svg.getElementById('b_low').getAttribute('fill'),
        b_inv: svg.getElementById('b_inv').getAttribute('fill')
      }
    } catch (err) {
      console.warn('Theme', 'Incomplete SVG Theme', err)
    }
  }
  function isValid (json) {
    if (!json) { return false }
    if (!json.background || !isColor(json.background)) { return false }
    if (!json.f_high || !isColor(json.f_high)) { return false }
    if (!json.f_med || !isColor(json.f_med)) { return false }
    if (!json.f_low || !isColor(json.f_low)) { return false }
    if (!json.f_inv || !isColor(json.f_inv)) { return false }
    if (!json.b_high || !isColor(json.b_high)) { return false }
    if (!json.b_med || !isColor(json.b_med)) { return false }
    if (!json.b_low || !isColor(json.b_low)) { return false }
    if (!json.b_inv || !isColor(json.b_inv)) { return false }
    return true
  }
  function isColor (hex) {
    return /^#([0-9A-F]{3}){1,2}$/i.test(hex)
  }
  function isJson (text) {
    try { JSON.parse(text); return true } catch (error) { return false }
  }
  function isHtml (text) {
    try { new DOMParser().parseFromString(text, 'text/xml'); return true } catch (error) { return false }
  }
}
'use strict'
function Client () {
  this.install = function (host) {
    console.info('Client', 'Installing..')
    this.acels = new Acels(this)
    this.theme = new Theme(this)
    this.history = new History(this)
    this.source = new Source(this)
    this.manager = new Manager(this)
    this.renderer = new Renderer(this)
    this.tool = new Tool(this)
    this.interface = new Interface(this)
    this.picker = new Picker(this)
    this.cursor = new Cursor(this)
    host.appendChild(this.renderer.el)
    document.addEventListener('mousedown', (e) => { this.cursor.down(e) }, false)
    document.addEventListener('mousemove', (e) => { this.cursor.move(e) }, false)
    document.addEventListener('contextmenu', (e) => { this.cursor.alt(e) }, false)
    document.addEventListener('mouseup', (e) => { this.cursor.up(e) }, false)
    document.addEventListener('copy', (e) => { this.copy(e) }, false)
    document.addEventListener('cut', (e) => { this.cut(e) }, false)
    document.addEventListener('paste', (e) => { this.paste(e) }, false)
    window.addEventListener('resize', (e) => { this.onResize() }, false)
    window.addEventListener('dragover', (e) => { e.stopPropagation(); e.preventDefault(); e.dataTransfer.dropEffect = 'copy' })
    window.addEventListener('drop', this.onDrop)
    this.acels.set('File', 'New', 'CmdOrCtrl+N', () => { this.source.new() })
    this.acels.set('File', 'Open', 'CmdOrCtrl+O', () => { this.source.open('grid', this.whenOpen) })
    this.acels.set('File', 'Save', 'CmdOrCtrl+S', () => { this.source.write('dotgrid', 'grid', this.tool.export(), 'text/plain') })
    this.acels.set('File', 'Export Vector', 'CmdOrCtrl+E', () => { this.source.write('dotgrid', 'svg', this.manager.toString(), 'image/svg+xml') })
    this.acels.set('File', 'Export Image', 'CmdOrCtrl+Shift+E', () => { this.manager.toPNG(this.tool.settings.size, (dataUrl) => { this.source.write('dotgrid', 'png', dataUrl, 'image/png') }) })
    this.acels.set('History', 'Undo', 'CmdOrCtrl+Z', () => { this.tool.undo() })
    this.acels.set('History', 'Redo', 'CmdOrCtrl+Shift+Z', () => { this.tool.redo() })
    this.acels.set('Stroke', 'Line', 'A', () => { this.tool.cast('line') })
    this.acels.set('Stroke', 'Arc', 'S', () => { this.tool.cast('arc_c') })
    this.acels.set('Stroke', 'Arc Rev', 'D', () => { this.tool.cast('arc_r') })
    this.acels.set('Stroke', 'Bezier', 'F', () => { this.tool.cast('bezier') })
    this.acels.set('Stroke', 'Close', 'Z', () => { this.tool.cast('close') })
    this.acels.set('Stroke', 'Arc(full)', 'T', () => { this.tool.cast('arc_c_full') })
    this.acels.set('Stroke', 'Arc Rev(full)', 'Y', () => { this.tool.cast('arc_r_full') })
    this.acels.set('Stroke', 'Clear Selection', 'Escape', () => { this.tool.clear() })
    this.acels.set('Effect', 'Linecap', 'Q', () => { this.tool.toggle('linecap') })
    this.acels.set('Effect', 'Linejoin', 'W', () => { this.tool.toggle('linejoin') })
    this.acels.set('Effect', 'Mirror', 'E', () => { this.tool.toggle('mirror') })
    this.acels.set('Effect', 'Fill', 'R', () => { this.tool.toggle('fill') })
    this.acels.set('Effect', 'Thicker', '}', () => { this.tool.toggle('thickness', 1) })
    this.acels.set('Effect', 'Thinner', '{', () => { this.tool.toggle('thickness', -1) })
    this.acels.set('Effect', 'Thicker +5', ']', () => { this.tool.toggle('thickness', 5) })
    this.acels.set('Effect', 'Thinner -5', '[', () => { this.tool.toggle('thickness', -5) })
    this.acels.set('Manual', 'Add Point', 'Enter', () => { this.tool.addVertex(this.cursor.pos); this.renderer.update() })
    this.acels.set('Manual', 'Move Up', 'Up', () => { this.cursor.pos.y -= 15; this.renderer.update() })
    this.acels.set('Manual', 'Move Right', 'Right', () => { this.cursor.pos.x += 15; this.renderer.update() })
    this.acels.set('Manual', 'Move Down', 'Down', () => { this.cursor.pos.y += 15; this.renderer.update() })
    this.acels.set('Manual', 'Move Left', 'Left', () => { this.cursor.pos.x -= 15; this.renderer.update() })
    this.acels.set('Manual', 'Remove Point', 'Shift+Backspace', () => { this.tool.removeSegmentsAt(this.cursor.pos) })
    this.acels.set('Manual', 'Remove Segment', 'Backspace', () => { this.tool.removeSegment() })
    this.acels.set('Layers', 'Foreground', 'CmdOrCtrl+1', () => { this.tool.selectLayer(0) })
    this.acels.set('Layers', 'Middleground', 'CmdOrCtrl+2', () => { this.tool.selectLayer(1) })
    this.acels.set('Layers', 'Background', 'CmdOrCtrl+3', () => { this.tool.selectLayer(2) })
    this.acels.set('Layers', 'Merge Layers', 'CmdOrCtrl+M', () => { this.tool.merge() })
    this.acels.set('View', 'Color Picker', 'G', () => { this.picker.start() })
    this.acels.set('View', 'Toggle Grid', 'H', () => { this.renderer.toggle() })
    this.acels.install(window)
    this.acels.pipe(this)
    this.manager.install()
    this.interface.install(host)
    this.theme.install(host, () => { this.update() })
  }
  this.start = () => {
    console.log('Client', 'Starting..')
    console.info(`${this.acels}`)
    this.theme.start()
    this.tool.start()
    this.renderer.start()
    this.interface.start()
    this.source.new()
    this.onResize()
    setTimeout(() => { document.body.className += ' ready' }, 250)
  }
  this.update = () => {
    this.manager.update()
    this.interface.update()
    this.renderer.update()
  }
  this.clear = () => {
    this.history.clear()
    this.tool.reset()
    this.reset()
    this.renderer.update()
    this.interface.update(true)
  }
  this.reset = () => {
    this.tool.clear()
    this.update()
  }
  this.whenOpen = (file, data) => {
    this.tool.replace(JSON.parse(data))
    this.onResize()
  }
  this.fitSize = () => {
    if (this.requireResize() === false) { return }
    console.log('Client', `Will resize to: ${printSize(this.getRequiredSize())}`)
    this.update()
  }
  this.getPadding = () => {
    return { x: 60, y: 90 }
  }
  this.getWindowSize = () => {
    return { width: window.innerWidth, height: window.innerHeight }
  }
  this.getProjectSize = () => {
    return this.tool.settings.size
  }
  this.getPaddedSize = () => {
    const rect = this.getWindowSize()
    const pad = this.getPadding()
    return { width: step(rect.width - pad.x, 15), height: step(rect.height - pad.y, 15) }
  }
  this.getRequiredSize = () => {
    const rect = this.getProjectSize()
    const pad = this.getPadding()
    return { width: step(rect.width, 15) + pad.x, height: step(rect.height, 15) + pad.y }
  }
  this.requireResize = () => {
    const _window = this.getWindowSize()
    const _required = this.getRequiredSize()
    const offset = sizeOffset(_window, _required)
    if (offset.width !== 0 || offset.height !== 0) {
      console.log('Client', `Require ${printSize(_required)}, but window is ${printSize(_window)}(${printSize(offset)})`)
      return true
    }
    return false
  }
  this.onResize = () => {
    const _project = this.getProjectSize()
    const _padded = this.getPaddedSize()
    const offset = sizeOffset(_padded, _project)
    if (offset.width !== 0 || offset.height !== 0) {
      console.log('Client', `Resize project to ${printSize(_padded)}`)
      this.tool.settings.size = _padded
    }
    this.update()
  }
  this.drag = function (e) {
    e.preventDefault()
    e.stopPropagation()
    const file = e.dataTransfer.files[0]
    const filename = file.path ? file.path : file.name ? file.name : ''
    if (filename.indexOf('.grid') < 0) { console.warn('Client', 'Not a .grid file'); return }
    const reader = new FileReader()
    reader.onload = function (e) {
      const data = e.target && e.target.result ? e.target.result : ''
      this.source.load(filename, data)
      this.fitSize()
    }
    reader.readAsText(file)
  }
  this.onDrop = (e) => {
    e.preventDefault()
    e.stopPropagation()
    const file = e.dataTransfer.files[0]
    if (file.name.indexOf('.grid') > -1) {
      this.source.read(e.dataTransfer.files[0], this.whenOpen)
    }
  }
  this.copy = function (e) {
    this.renderer.update()
    if (e.target !== this.picker.input) {
      e.clipboardData.setData('text/source', this.tool.export(this.tool.layer()))
      e.clipboardData.setData('text/plain', this.tool.path())
      e.clipboardData.setData('text/html', this.manager.el.outerHTML)
      e.clipboardData.setData('text/svg+xml', this.manager.el.outerHTML)
      e.preventDefault()
    }
    this.renderer.update()
  }
  this.cut = function (e) {
    this.renderer.update()
    if (e.target !== this.picker.input) {
      e.clipboardData.setData('text/source', this.tool.export(this.tool.layer()))
      e.clipboardData.setData('text/plain', this.tool.export(this.tool.layer()))
      e.clipboardData.setData('text/html', this.manager.el.outerHTML)
      e.clipboardData.setData('text/svg+xml', this.manager.el.outerHTML)
      this.tool.layers[this.tool.index] = []
      e.preventDefault()
    }
    this.renderer.update()
  }
  this.paste = function (e) {
    if (e.target !== this.picker.el) {
      let data = e.clipboardData.getData('text/source')
      if (isJson(data)) {
        data = JSON.parse(data.trim())
        this.tool.import(data)
      }
      e.preventDefault()
    }
    this.renderer.update()
  }
  this.onKeyDown = (e) => {
  }
  this.onKeyUp = (e) => {
  }
  function sizeOffset (a, b) { return { width: a.width - b.width, height: a.height - b.height } }
  function printSize (size) { return `${size.width}x${size.height}` }
  function isJson (text) { try { JSON.parse(text); return true } catch (error) { return false } }
  function step (v, s) { return Math.round(v / s) * s }
}
'use strict'
function Cursor (client) {
  this.pos = { x: 0, y: 0 }
  this.lastPos = { x: 0, y: 0 }
  this.translation = null
  this.operation = null
  this.translate = function (from = null, to = null, multi = false, copy = false, layer = false) {
    if ((from || to) && this.translation === null) { this.translation = { multi: multi, copy: copy, layer: layer } }
    if (from) { this.translation.from = from }
    if (to) { this.translation.to = to }
    if (!from && !to) {
      this.translation = null
    }
  }
  this.down = function (e) {
    this.pos = this.atEvent(e)
    if (client.tool.vertexAt(this.pos)) {
      this.translate(this.pos, this.pos, e.shiftKey, e.ctrlKey || e.metaKey, e.altKey)
    }
    client.renderer.update()
    client.interface.update()
    e.preventDefault()
  }
  this.move = function (e) {
    this.pos = this.atEvent(e)
    if (this.translation) {
      this.translate(null, this.pos)
    }
    if (this.lastPos.x !== this.pos.x || this.lastPos.y !== this.pos.y) {
      client.renderer.update()
    }
    client.interface.update()
    this.lastPos = this.pos
    e.preventDefault()
  }
  this.up = function (e) {
    this.pos = this.atEvent(e)
    if (this.translation && !isEqual(this.translation.from, this.translation.to)) {
      if (this.translation.layer === true) { client.tool.translateLayer(this.translation.from, this.translation.to) } else if (this.translation.copy) { client.tool.translateCopy(this.translation.from, this.translation.to) } else if (this.translation.multi) { client.tool.translateMulti(this.translation.from, this.translation.to) } else { client.tool.translate(this.translation.from, this.translation.to) }
    } else if (e.target.id === 'guide') {
      client.tool.addVertex({ x: this.pos.x, y: this.pos.y })
      client.picker.stop()
    }
    this.translate()
    client.interface.update()
    client.renderer.update()
    e.preventDefault()
  }
  this.alt = function (e) {
    this.pos = this.atEvent(e)
    client.tool.removeSegmentsAt(this.pos)
    e.preventDefault()
    setTimeout(() => {
      client.tool.clear()
    }, 150)
  }
  this.atEvent = function (e) {
    return this.snapPos(this.relativePos({ x: e.clientX, y: e.clientY }))
  }
  this.relativePos = function (pos) {
    return {
      x: pos.x - client.renderer.el.offsetLeft,
      y: pos.y - client.renderer.el.offsetTop
    }
  }
  this.snapPos = function (pos) {
    return {
      x: clamp(step(pos.x, 15), 15, client.tool.settings.size.width - 15),
      y: clamp(step(pos.y, 15), 15, client.tool.settings.size.height - 15)
    }
  }
  function isEqual (a, b) { return a.x === b.x && a.y === b.y }
  function clamp (v, min, max) { return v < min ? min : v > max ? max : v }
  function step (v, s) { return Math.round(v / s) * s }
}
'use strict'
function Generator (layer, style) {
  this.layer = layer
  this.style = style
  function operate (layer, offset, scale, mirror = 0, angle = 0) {
    const l = copy(layer)
    for (const k1 in l) {
      const seg = l[k1]
      for (const k2 in seg.vertices) {
        if (mirror === 1 || mirror === 3) { seg.vertices[k2].x = (client.tool.settings.size.width) - seg.vertices[k2].x }
        if (mirror === 2 || mirror === 3) { seg.vertices[k2].y = (client.tool.settings.size.height) - seg.vertices[k2].y }
        seg.vertices[k2].x += offset.x
        seg.vertices[k2].y += offset.y
        const center = { x: (client.tool.settings.size.width / 2) + offset.x + (7.5), y: (client.tool.settings.size.height / 2) + offset.y + 30 }
        seg.vertices[k2] = rotatePoint(seg.vertices[k2], center, angle)
        seg.vertices[k2].x *= scale
        seg.vertices[k2].y *= scale
      }
    }
    return l
  }
  this.render = function (prev, segment, mirror = 0) {
    const type = segment.type
    const vertices = segment.vertices
    let html = ''
    let skip = 0
    for (const id in vertices) {
      if (skip > 0) { skip -= 1; continue }
      const vertex = vertices[parseInt(id)]
      const next = vertices[parseInt(id) + 1]
      const afterNext = vertices[parseInt(id) + 2]
      if (parseInt(id) === 0 && !prev) {
        html += `M${vertex.x},${vertex.y} `
      } else if (parseInt(id) === 0 && prev && (prev.x !== vertex.x || prev.y !== vertex.y)) {
        html += `M${vertex.x},${vertex.y} `
      }
      if (type === 'line') {
        html += this._line(vertex)
      } else if (type === 'arc_c') {
        const clock = mirror > 0 && mirror < 3 ? '0,0' : '0,1'
        html += this._arc(vertex, next, clock)
      } else if (type === 'arc_r') {
        const clock = mirror > 0 && mirror < 3 ? '0,1' : '0,0'
        html += this._arc(vertex, next, clock)
      } else if (type === 'arc_c_full') {
        const clock = mirror > 0 ? '1,0' : '1,1'
        html += this._arc(vertex, next, clock)
      } else if (type === 'arc_r_full') {
        const clock = mirror > 0 ? '1,1' : '1,0'
        html += this._arc(vertex, next, clock)
      } else if (type === 'bezier') {
        html += this._bezier(next, afterNext)
        skip = 1
      }
    }
    if (segment.type === 'close') {
      html += 'Z '
    }
    return html
  }
  this._line = function (a) {
    return `L${a.x},${a.y} `
  }
  this._arc = function (a, b, c) {
    if (!a || !b || !c) { return '' }
    const offset = { x: b.x - a.x, y: b.y - a.y }
    if (offset.x === 0 || offset.y === 0) { return this._line(b) }
    return `A${Math.abs(b.x - a.x)},${Math.abs(b.y - a.y)} 0 ${c} ${b.x},${b.y} `
  }
  this._bezier = function (a, b) {
    if (!a || !b) { return '' }
    return `Q${a.x},${a.y} ${b.x},${b.y} `
  }
  this.convert = function (layer, mirror, angle) {
    let s = ''
    let prev = null
    for (const id in layer) {
      const seg = layer[parseInt(id)]
      s += `${this.render(prev, seg, mirror)}`
      prev = seg.vertices ? seg.vertices[seg.vertices.length - 1] : null
    }
    return s
  }
  this.toString = function (offset = { x: 0, y: 0 }, scale = 1, mirror = this.style && this.style.mirror_style ? this.style.mirror_style : 0) {
    let s = this.convert(operate(this.layer, offset, scale))
    if (mirror === 1 || mirror === 2 || mirror === 3) {
      s += this.convert(operate(this.layer, offset, scale, mirror), mirror)
    }
    return s
  }
  function copy (data) { return data ? JSON.parse(JSON.stringify(data)) : [] }
  function rotatePoint (point, origin, angle) { angle = angle * Math.PI / 180.0; return { x: (Math.cos(angle) * (point.x - origin.x) - Math.sin(angle) * (point.y - origin.y) + origin.x).toFixed(1), y: (Math.sin(angle) * (point.x - origin.x) + Math.cos(angle) * (point.y - origin.y) + origin.y).toFixed(1) } }
}
'use strict'
function Interface (client) {
  this.el = document.createElement('div')
  this.el.id = 'interface'
  this.el.appendChild(this.menu_el = document.createElement('div'))
  this.menu_el.id = 'menu'
  this.isVisible = true
  this.zoom = false
  this.install = function (host) {
    host.appendChild(this.el)
  }
  this.start = function (host) {
    let html = ''
    const options = {
      cast: {
        line: { key: 'A', icon: 'M60,60 L240,240' },
        arc_c: { key: 'S', icon: 'M60,60 A180,180 0 0,1 240,240' },
        arc_r: { key: 'D', icon: 'M60,60 A180,180 0 0,0 240,240' },
        bezier: { key: 'F', icon: 'M60,60 Q60,150 150,150 Q240,150 240,240' },
        close: { key: 'Z', icon: 'M60,60 A180,180 0 0,1 240,240  M60,60 A180,180 0 0,0 240,240' }
      },
      toggle: {
        linecap: { key: 'Q', icon: 'M60,60 L60,60 L180,180 L240,180 L240,240 L180,240 L180,180' },
        linejoin: { key: 'W', icon: 'M60,60 L120,120 L180,120  M120,180 L180,180 L240,240' },
        thickness: { key: '', icon: 'M120,90 L120,90 L90,120 L180,210 L210,180 Z M105,105 L105,105 L60,60 M195,195 L195,195 L240,240' },
        mirror: { key: 'E', icon: 'M60,60 L60,60 L120,120 M180,180 L180,180 L240,240 M210,90 L210,90 L180,120 M120,180 L120,180 L90,210' },
        fill: { key: 'R', icon: 'M60,60 L60,150 L150,150 L240,150 L240,240 Z' }
      },
      misc: {
        color: { key: 'G', icon: 'M150,60 A90,90 0 0,1 240,150 A-90,90 0 0,1 150,240 A-90,-90 0 0,1 60,150 A90,-90 0 0,1 150,60' }
      },
      source: {
        open: { key: 'c-O', icon: 'M155,65 A90,90 0 0,1 245,155 A90,90 0 0,1 155,245 A90,90 0 0,1 65,155 A90,90 0 0,1 155,65 M155,95 A60,60 0 0,1 215,155 A60,60 0 0,1 155,215 A60,60 0 0,1 95,155 A60,60 0 0,1 155,95 ' },
        render: { key: 'c-R', icon: 'M155,65 A90,90 0 0,1 245,155 A90,90 0 0,1 155,245 A90,90 0 0,1 65,155 A90,90 0 0,1 155,65 M110,155 L110,155 L200,155 ' },
        export: { key: 'c-E', icon: 'M155,65 A90,90 0 0,1 245,155 A90,90 0 0,1 155,245 A90,90 0 0,1 65,155 A90,90 0 0,1 155,65 M110,140 L110,140 L200,140 M110,170 L110,170 L200,170' },
        save: { key: 'c-S', icon: 'M155,65 A90,90 0 0,1 245,155 A90,90 0 0,1 155,245 A90,90 0 0,1 65,155 A90,90 0 0,1 155,65 M110,155 L110,155 L200,155 M110,185 L110,185 L200,185 M110,125 L110,125 L200,125' },
        grid: { key: 'H', icon: 'M65,155 Q155,245 245,155 M65,155 Q155,65 245,155 M155,125 A30,30 0 0,1 185,155 A30,30 0 0,1 155,185 A30,30 0 0,1 125,155 A30,30 0 0,1 155,125 ' }
      }
    }
    for (const type in options) {
      const tools = options[type]
      for (const name in tools) {
        const tool = tools[name]
        html += `
        <svg 
          id="option_${name}" 
          title="${capitalize(name)}" 
          onmouseout="client.interface.out('${type}','${name}')" 
          onmouseup="client.interface.up('${type}','${name}')" 
          onmousedown="client.interface.down('${type}','${name}', event)" 
          onmouseover="client.interface.over('${type}','${name}')" 
          viewBox="0 0 300 300" 
          class="icon ${type}">
          <path id="${name}_path" class="icon_path" d="${tool.icon}"/>${name === 'depth' ? '<path class="icon_path inactive" d=""/>' : ''}
          <rect ar="${name}" width="300" height="300" opacity="0">
            <title>${capitalize(name)}${tool.key ? '(' + tool.key + ')' : ''}</title>
          </rect>
        </svg>`
      }
    }
    this.menu_el.innerHTML = html
    this.menu_el.appendChild(client.picker.el)
  }
  this.over = function (type, name) {
    client.cursor.operation = {}
    client.cursor.operation[type] = name
    this.update(true)
    client.renderer.update(true)
  }
  this.out = function (type, name) {
    client.cursor.operation = ''
    client.renderer.update(true)
  }
  this.up = function (type, name) {
    if (!client.tool[type]) { console.warn(`Unknown option(type): ${type}.${name}`, client.tool); return }
    this.update(true)
    client.renderer.update(true)
  }
  this.down = function (type, name, event) {
    if (!client.tool[type]) { console.warn(`Unknown option(type): ${type}.${name}`, client.tool); return }
    const mod = event.button === 2 ? -1 : 1
    client.tool[type](name, mod)
    this.update(true)
    client.renderer.update(true)
  }
  this.prev_operation = null
  this.update = function (force = false, id) {
    if (this.prev_operation === client.cursor.operation && force === false) { return }
    let multiVertices = null
    const segments = client.tool.layer()
    const sumSegments = client.tool.length()
    for (const i in segments) {
      if (segments[i].vertices.length > 2) { multiVertices = true; break }
    }
    document.getElementById('option_line').className.baseVal = !client.tool.canCast('line') ? 'icon inactive' : 'icon'
    document.getElementById('option_arc_c').className.baseVal = !client.tool.canCast('arc_c') ? 'icon inactive' : 'icon'
    document.getElementById('option_arc_r').className.baseVal = !client.tool.canCast('arc_r') ? 'icon inactive' : 'icon'
    document.getElementById('option_bezier').className.baseVal = !client.tool.canCast('bezier') ? 'icon inactive' : 'icon'
    document.getElementById('option_close').className.baseVal = !client.tool.canCast('close') ? 'icon inactive' : 'icon'
    document.getElementById('option_thickness').className.baseVal = client.tool.layer().length < 1 ? 'icon inactive' : 'icon'
    document.getElementById('option_linecap').className.baseVal = client.tool.layer().length < 1 ? 'icon inactive' : 'icon'
    document.getElementById('option_linejoin').className.baseVal = client.tool.layer().length < 1 || !multiVertices ? 'icon inactive' : 'icon'
    document.getElementById('option_mirror').className.baseVal = client.tool.layer().length < 1 ? 'icon inactive' : 'icon'
    document.getElementById('option_fill').className.baseVal = client.tool.layer().length < 1 ? 'icon inactive' : 'icon'
    document.getElementById('option_color').children[0].style.fill = client.tool.style().color
    document.getElementById('option_color').children[0].style.stroke = client.tool.style().color
    document.getElementById('option_color').className.baseVal = 'icon'
    document.getElementById('option_save').className.baseVal = sumSegments < 1 ? 'icon inactive source' : 'icon source'
    document.getElementById('option_export').className.baseVal = sumSegments < 1 ? 'icon inactive source' : 'icon source'
    document.getElementById('option_render').className.baseVal = sumSegments < 1 ? 'icon inactive source' : 'icon source'
    document.getElementById('option_grid').className.baseVal = client.renderer.showExtras ? 'icon inactive source' : 'icon source'
    if (client.renderer.showExtras) { document.getElementById('grid_path').setAttribute('d', 'M65,155 Q155,245 245,155 M65,155 Q155,65 245,155 M155,125 A30,30 0 0,1 185,155 A30,30 0 0,1 155,185 A30,30 0 0,1 125,155 A30,30 0 0,1 155,125 ') } else { document.getElementById('grid_path').setAttribute('d', 'M65,155 Q155,245 245,155 M65,155 ') }
    if (client.tool.style().mirror_style === 0) { document.getElementById('mirror_path').setAttribute('d', 'M60,60 L60,60 L120,120 M180,180 L180,180 L240,240 M210,90 L210,90 L180,120 M120,180 L120,180 L90,210') } else if (client.tool.style().mirror_style === 1) { document.getElementById('mirror_path').setAttribute('d', 'M60,60 L240,240 M180,120 L210,90 M120,180 L90,210') } else if (client.tool.style().mirror_style === 2) { document.getElementById('mirror_path').setAttribute('d', 'M210,90 L210,90 L90,210 M60,60 L60,60 L120,120 M180,180 L180,180 L240,240') } else if (client.tool.style().mirror_style === 3) { document.getElementById('mirror_path').setAttribute('d', 'M60,60 L60,60 L120,120 L180,120 L210,90 M240,240 L240,240 L180,180 L120,180 L90,210') } else if (client.tool.style().mirror_style === 4) { document.getElementById('mirror_path').setAttribute('d', 'M120,120 L120,120 L120,120 L180,120 M120,150 L120,150 L180,150 M120,180 L120,180 L180,180 L180,180 L180,180 L240,240 M120,210 L120,210 L180,210 M120,90 L120,90 L180,90 M60,60 L60,60 L120,120  ') }
    this.prev_operation = client.cursor.operation
  }
  this.toggle = function () {
    this.isVisible = !this.isVisible
    this.el.className = this.isVisible ? 'visible' : 'hidden'
  }
  document.onkeydown = function (e) {
    if (e.key === 'Tab') {
      client.interface.toggle()
      e.preventDefault()
    }
  }
  function capitalize (str) {
    return str.charAt(0).toUpperCase() + str.slice(1).toLowerCase()
  }
}
'use strict'
function Manager (client) {
  this.el = document.createElementNS('http://www.w3.org/2000/svg', 'svg')
  this.el.setAttribute('xmlns', 'http://www.w3.org/2000/svg')
  this.el.setAttribute('baseProfile', 'full')
  this.el.setAttribute('version', '1.1')
  this.el.style.fill = 'none'
  this.layers = []
  this.install = function () {
    this.el.appendChild(this.layers[2] = document.createElementNS('http://www.w3.org/2000/svg', 'path'))
    this.el.appendChild(this.layers[1] = document.createElementNS('http://www.w3.org/2000/svg', 'path'))
    this.el.appendChild(this.layers[0] = document.createElementNS('http://www.w3.org/2000/svg', 'path'))
  }
  this.update = function () {
    this.el.setAttribute('width', (client.tool.settings.size.width) + 'px')
    this.el.setAttribute('height', (client.tool.settings.size.height) + 'px')
    this.el.style.width = (client.tool.settings.size.width)
    this.el.style.height = client.tool.settings.size.height
    const styles = client.tool.styles
    const paths = client.tool.paths()
    for (const id in this.layers) {
      const style = styles[id]
      const path = paths[id]
      const layer = this.layers[id]
      layer.style.strokeWidth = style.thickness
      layer.style.strokeLinecap = style.strokeLinecap
      layer.style.strokeLinejoin = style.strokeLinejoin
      layer.style.stroke = style.color
      layer.style.fill = style.fill
      layer.setAttribute('d', path)
    }
  }
  this.svg64 = function () {
    const xml = new XMLSerializer().serializeToString(this.el)
    const svg64 = btoa(xml)
    const b64Start = 'data:image/svg+xml;base64,'
    return b64Start + svg64
  }
  this.toPNG = function (size = client.tool.settings.size, callback) {
    this.update()
    const image64 = this.svg64()
    const img = new Image()
    const canvas = document.createElement('canvas')
    canvas.width = (size.width) * 2
    canvas.height = (size.height) * 2
    img.onload = function () {
      canvas.getContext('2d').drawImage(img, 0, 0, (size.width) * 2, (size.height) * 2)
      callback(canvas.toDataURL('image/png'))
    }
    img.src = image64
  }
  this.toSVG = function (callback) {
    this.update()
    const image64 = this.svg64()
    callback(image64, 'export.svg')
  }
  this.toGRID = function (callback) {
    this.update()
    const text = client.tool.export()
    const file = new Blob([text], { type: 'text/plain' })
    callback(URL.createObjectURL(file), 'export.grid')
  }
  this.toString = () => {
    return new XMLSerializer().serializeToString(this.el)
  }
}
'use strict'
function Picker (client) {
  this.memory = ''
  this.el = document.createElement('div')
  this.el.id = 'picker'
  this.isActive = false
  this.input = document.createElement('input')
  this.input.id = 'picker_input'
  this.el.appendChild(this.input)
  this.start = function () {
    if (this.isActive) { return }
    this.isActive = true
    this.input.setAttribute('placeholder', `${client.tool.style().color.replace('#', '').trim()}`)
    this.input.setAttribute('maxlength', 6)
    this.input.addEventListener('keydown', this.onKeyDown, false)
    this.input.addEventListener('keyup', this.onKeyUp, false)
    client.interface.el.className = 'picker'
    this.input.focus()
    this.input.value = ''
    try { client.controller.set('picker') } catch (err) { }
  }
  this.update = function () {
    if (!this.isActive) { return }
    if (!isColor(this.input.value)) { return }
    const hex = `#${this.input.value}`
    document.getElementById('option_color').children[0].style.fill = hex
    document.getElementById('option_color').children[0].style.stroke = hex
  }
  this.stop = function () {
    if (!this.isActive) { return }
    this.isActive = false
    client.interface.el.className = ''
    this.input.blur()
    this.input.value = ''
    try { client.controller.set() } catch (err) { console.log('No controller') }
    setTimeout(() => { client.interface.update(true); client.renderer.update() }, 250)
  }
  this.validate = function () {
    if (!isColor(this.input.value)) { return }
    const hex = `#${this.input.value}`
    client.tool.style().color = hex
    client.tool.style().fill = client.tool.style().fill !== 'none' ? hex : 'none'
    this.stop()
  }
  function isColor (val) {
    if (val.length !== 3 && val.length !== 6) {
      return false
    }
    const re = /[0-9A-Fa-f]/g
    return re.test(val)
  }
  this.onKeyDown = (e) => {
    e.stopPropagation()
    if (e.key === 'Enter') {
      this.validate()
      e.preventDefault()
      return
    }
    if (e.key === 'Escape') {
      this.stop()
      e.preventDefault()
    }
  }
  this.onKeyUp = (e) => {
    e.stopPropagation()
    this.update()
  }
}
'use strict'
function Renderer (client) {
  this.el = document.createElement('canvas')
  this.el.id = 'guide'
  this.el.width = 640
  this.el.height = 640
  this.el.style.width = '320px'
  this.el.style.height = '320px'
  this.context = this.el.getContext('2d')
  this.showExtras = true
  this.scale = 2 // window.devicePixelRatio
  this.start = function () {
    this.update()
  }
  this.update = function (force = false) {
    this.resize()
    client.manager.update()
    const render = new Image()
    render.onload = () => {
      this.draw(render)
    }
    render.src = client.manager.svg64()
  }
  this.draw = function (render) {
    this.clear()
    this.drawMirror()
    this.drawGrid()
    this.drawRulers()
    this.drawRender(render) //
    this.drawVertices()
    this.drawHandles()
    this.drawTranslation()
    this.drawCursor()
    this.drawPreview()
  }
  this.clear = function () {
    this.context.clearRect(0, 0, this.el.width * this.scale, this.el.height * this.scale)
  }
  this.toggle = function () {
    this.showExtras = !this.showExtras
    this.update()
    client.interface.update(true)
  }
  this.resize = function () {
    const _target = client.getPaddedSize()
    const _current = { width: this.el.width / this.scale, height: this.el.height / this.scale }
    const offset = sizeOffset(_target, _current)
    if (offset.width === 0 && offset.height === 0) {
      return
    }
    console.log('Renderer', `Require resize: ${printSize(_target)}, from ${printSize(_current)}`)
    this.el.width = (_target.width) * this.scale
    this.el.height = (_target.height) * this.scale
    this.el.style.width = (_target.width) + 'px'
    this.el.style.height = (_target.height) + 'px'
  }
  this.drawMirror = function () {
    if (!this.showExtras) { return }
    if (client.tool.style().mirror_style === 0) { return }
    const middle = { x: client.tool.settings.size.width, y: client.tool.settings.size.height }
    if (client.tool.style().mirror_style === 1 || client.tool.style().mirror_style === 3) {
      this.drawRule({ x: middle.x, y: 15 * this.scale }, { x: middle.x, y: (client.tool.settings.size.height) * this.scale })
    }
    if (client.tool.style().mirror_style === 2 || client.tool.style().mirror_style === 3) {
      this.drawRule({ x: 15 * this.scale, y: middle.y }, { x: (client.tool.settings.size.width) * this.scale, y: middle.y })
    }
  }
  this.drawHandles = function () {
    if (!this.showExtras) { return }
    for (const segmentId in client.tool.layer()) {
      const segment = client.tool.layer()[segmentId]
      for (const vertexId in segment.vertices) {
        const vertex = segment.vertices[vertexId]
        this.drawHandle(vertex)
      }
    }
  }
  this.drawVertices = function () {
    for (const id in client.tool.vertices) {
      this.drawVertex(client.tool.vertices[id])
    }
  }
  this.drawGrid = function () {
    if (!this.showExtras) { return }
    const markers = { w: parseInt(client.tool.settings.size.width / 15), h: parseInt(client.tool.settings.size.height / 15) }
    for (let x = markers.w - 1; x >= 0; x--) {
      for (let y = markers.h - 1; y >= 0; y--) {
        const isStep = x % 4 === 0 && y % 4 === 0
        if (x === 0 || y === 0) { continue }
        this.drawMarker({
          x: parseInt(x * 15),
          y: parseInt(y * 15)
        }, isStep ? 2.5 : 1.5, client.theme.active.b_med)
      }
    }
  }
  this.drawRulers = function () {
    if (!client.cursor.translation) { return }
    const pos = client.cursor.translation.to
    const bottom = (client.tool.settings.size.height * this.scale)
    const right = (client.tool.settings.size.width * this.scale)
    this.drawRule({ x: pos.x * this.scale, y: 0 }, { x: pos.x * this.scale, y: bottom })
    this.drawRule({ x: 0, y: pos.y * this.scale }, { x: right, y: pos.y * this.scale })
  }
  this.drawPreview = function () {
    const operation = client.cursor.operation && client.cursor.operation.cast ? client.cursor.operation.cast : null
    if (!client.tool.canCast(operation)) { return }
    if (operation === 'close') { return }
    const path = new Generator([{ vertices: client.tool.vertices, type: operation }]).toString({ x: 0, y: 0 }, 2)
    const style = {
      color: client.theme.active.f_med,
      thickness: 2,
      strokeLinecap: 'round',
      strokeLinejoin: 'round',
      strokeLineDash: [5, 15]
    }
    this.drawPath(path, style)
  }
  this.drawMarker = function (pos, radius = 1, color) {
    this.context.beginPath()
    this.context.lineWidth = 2
    this.context.arc(pos.x * this.scale, pos.y * this.scale, radius, 0, 2 * Math.PI, false)
    this.context.fillStyle = color
    this.context.fill()
    this.context.closePath()
  }
  this.drawVertex = function (pos, radius = 5) {
    this.context.beginPath()
    this.context.lineWidth = 2
    this.context.arc((pos.x * this.scale), (pos.y * this.scale), radius, 0, 2 * Math.PI, false)
    this.context.fillStyle = client.theme.active.f_low
    this.context.fill()
    this.context.closePath()
  }
  this.drawRule = function (from, to) {
    this.context.beginPath()
    this.context.moveTo(from.x, from.y)
    this.context.lineTo(to.x, to.y)
    this.context.lineCap = 'round'
    this.context.lineWidth = 3
    this.context.strokeStyle = client.theme.active.b_low
    this.context.stroke()
    this.context.closePath()
  }
  this.drawHandle = function (pos, radius = 6) {
    this.context.beginPath()
    this.context.arc(Math.abs(pos.x * -this.scale), Math.abs(pos.y * this.scale), radius + 3, 0, 2 * Math.PI, false)
    this.context.fillStyle = client.theme.active.f_high
    this.context.fill()
    this.context.closePath()
    this.context.beginPath()
    this.context.arc((pos.x * this.scale), (pos.y * this.scale), radius - 3, 0, 2 * Math.PI, false)
    this.context.fillStyle = client.theme.active.b_low
    this.context.fill()
    this.context.closePath()
  }
  this.drawPath = function (path, style) {
    const p = new Path2D(path)
    this.context.strokeStyle = style.color
    this.context.lineWidth = style.thickness * this.scale
    this.context.lineCap = style.strokeLinecap
    this.context.lineJoin = style.strokeLinejoin
    if (style.fill && style.fill !== 'none') {
      this.context.fillStyle = style.color
      this.context.fill(p)
    }
    this.context.save()
    if (style.strokeLineDash) { this.context.setLineDash(style.strokeLineDash) } else { this.context.setLineDash([]) }
    this.context.stroke(p)
    this.context.restore()
  }
  this.drawTranslation = function () {
    if (!client.cursor.translation) { return }
    this.context.save()
    this.context.beginPath()
    this.context.moveTo((client.cursor.translation.from.x * this.scale), (client.cursor.translation.from.y * this.scale))
    this.context.lineTo((client.cursor.translation.to.x * this.scale), (client.cursor.translation.to.y * this.scale))
    this.context.lineCap = 'round'
    this.context.lineWidth = 5
    this.context.strokeStyle = client.cursor.translation.multi === true ? client.theme.active.b_inv : client.cursor.translation.copy === true ? client.theme.active.f_med : client.theme.active.f_low
    this.context.setLineDash([5, 10])
    this.context.stroke()
    this.context.closePath()
    this.context.setLineDash([])
    this.context.restore()
  }
  this.drawCursor = function (pos = client.cursor.pos, radius = client.tool.style().thickness - 1) {
    this.context.save()
    this.context.beginPath()
    this.context.lineWidth = 3
    this.context.lineCap = 'round'
    this.context.arc(Math.abs(pos.x * -this.scale), Math.abs(pos.y * this.scale), 5, 0, 2 * Math.PI, false)
    this.context.strokeStyle = client.theme.active.background
    this.context.stroke()
    this.context.closePath()
    this.context.beginPath()
    this.context.lineWidth = 3
    this.context.lineCap = 'round'
    this.context.arc(Math.abs(pos.x * -this.scale), Math.abs(pos.y * this.scale), clamp(radius, 5, 100), 0, 2 * Math.PI, false)
    this.context.strokeStyle = client.theme.active.f_med
    this.context.stroke()
    this.context.closePath()
    this.context.restore()
  }
  this.drawRender = function (render) {
    this.context.drawImage(render, 0, 0, this.el.width, this.el.height)
  }
  function printSize (size) { return `${size.width}x${size.height}` }
  function sizeOffset (a, b) { return { width: a.width - b.width, height: a.height - b.height } }
  function clamp (v, min, max) { return v < min ? min : v > max ? max : v }
}
'use strict'
function Tool (client) {
  this.index = 0
  this.settings = { size: { width: 600, height: 300 } }
  this.layers = [[], [], []]
  this.styles = [
    { thickness: 15, strokeLinecap: 'round', strokeLinejoin: 'round', color: '#f00', fill: 'none', mirror_style: 0, transform: 'rotate(45)' },
    { thickness: 15, strokeLinecap: 'round', strokeLinejoin: 'round', color: '#0f0', fill: 'none', mirror_style: 0, transform: 'rotate(45)' },
    { thickness: 15, strokeLinecap: 'round', strokeLinejoin: 'round', color: '#00f', fill: 'none', mirror_style: 0, transform: 'rotate(45)' }
  ]
  this.vertices = []
  this.reqs = { line: 2, arc_c: 2, arc_r: 2, arc_c_full: 2, arc_r_full: 2, bezier: 3, close: 0 }
  this.start = function () {
    this.styles[0].color = client.theme.active.f_high
    this.styles[1].color = client.theme.active.f_med
    this.styles[2].color = client.theme.active.f_low
  }
  this.erase = function () {
    this.layers = [[], [], []]
  }
  this.reset = function () {
    this.styles[0].mirror_style = 0
    this.styles[1].mirror_style = 0
    this.styles[2].mirror_style = 0
    this.styles[0].fill = 'none'
    this.styles[1].fill = 'none'
    this.styles[2].fill = 'none'
    this.erase()
    this.vertices = []
    this.index = 0
  }
  this.clear = function () {
    this.vertices = []
    client.renderer.update()
    client.interface.update(true)
  }
  this.undo = function () {
    this.layers = client.history.prev()
    client.renderer.update()
    client.interface.update(true)
  }
  this.redo = function () {
    this.layers = client.history.next()
    client.renderer.update()
    client.interface.update(true)
  }
  this.length = function () {
    return this.layers[0].length + this.layers[1].length + this.layers[2].length
  }
  this.export = function (target = { settings: this.settings, layers: this.layers, styles: this.styles }) {
    return JSON.stringify(copy(target), null, 2)
  }
  this.import = function (layer) {
    this.layers[this.index] = this.layers[this.index].concat(layer)
    client.history.push(this.layers)
    this.clear()
    client.renderer.update()
    client.interface.update(true)
  }
  this.replace = function (dot) {
    if (!dot.layers || dot.layers.length !== 3) { console.warn('Incompatible version'); return }
    if (dot.settings.width && dot.settings.height) {
      dot.settings.size = { width: dot.settings.width, height: dot.settings.height }
    }
    this.layers = dot.layers
    this.styles = dot.styles
    this.settings = dot.settings
    this.clear()
    client.fitSize()
    client.renderer.update()
    client.interface.update(true)
    client.history.push(this.layers)
  }
  this.removeSegment = function () {
    if (this.vertices.length > 0) { this.clear(); return }
    this.layer().pop()
    this.clear()
    client.renderer.update()
    client.interface.update(true)
  }
  this.removeSegmentsAt = function (pos) {
    for (const segmentId in this.layer()) {
      const segment = this.layer()[segmentId]
      for (const vertexId in segment.vertices) {
        const vertex = segment.vertices[vertexId]
        if (Math.abs(pos.x) === Math.abs(vertex.x) && Math.abs(pos.y) === Math.abs(vertex.y)) {
          segment.vertices.splice(vertexId, 1)
        }
      }
      if (segment.vertices.length < 2) {
        this.layers[this.index].splice(segmentId, 1)
      }
    }
    this.clear()
    client.renderer.update()
    client.interface.update(true)
  }
  this.selectSegmentAt = function (pos, source = this.layer()) {
    for (const segmentId in source) {
      const segment = source[segmentId]
      for (const vertexId in segment.vertices) {
        const vertex = segment.vertices[vertexId]
        if (vertex.x === Math.abs(pos.x) && vertex.y === Math.abs(pos.y)) {
          return segment
        }
      }
    }
    return null
  }
  this.addVertex = function (pos) {
    pos = { x: Math.abs(pos.x), y: Math.abs(pos.y) }
    this.vertices.push(pos)
    client.interface.update(true)
  }
  this.vertexAt = function (pos) {
    for (const segmentId in this.layer()) {
      const segment = this.layer()[segmentId]
      for (const vertexId in segment.vertices) {
        const vertex = segment.vertices[vertexId]
        if (vertex.x === Math.abs(pos.x) && vertex.y === Math.abs(pos.y)) {
          return vertex
        }
      }
    }
    return null
  }
  this.addSegment = function (type, vertices, index = this.index) {
    const appendTarget = this.canAppend({ type: type, vertices: vertices }, index)
    if (appendTarget) {
      this.layer(index)[appendTarget].vertices = this.layer(index)[appendTarget].vertices.concat(vertices)
    } else {
      this.layer(index).push({ type: type, vertices: vertices })
    }
  }
  this.cast = function (type) {
    if (!this.layer()) { this.layers[this.index] = [] }
    if (!this.canCast(type)) { console.warn('Cannot cast'); return }
    this.addSegment(type, this.vertices.slice())
    client.history.push(this.layers)
    this.clear()
    client.renderer.update()
    client.interface.update(true)
    console.log(`Casted ${type} -> ${this.layer().length} elements`)
  }
  this.i = { linecap: 0, linejoin: 0, thickness: 5 }
  this.toggle = function (type, mod = 1) {
    if (type === 'linecap') {
      const a = ['butt', 'square', 'round']
      this.i.linecap += mod
      this.style().strokeLinecap = a[this.i.linecap % a.length]
    } else if (type === 'linejoin') {
      const a = ['miter', 'round', 'bevel']
      this.i.linejoin += mod
      this.style().strokeLinejoin = a[this.i.linejoin % a.length]
    } else if (type === 'fill') {
      this.style().fill = this.style().fill === 'none' ? this.style().color : 'none'
    } else if (type === 'thickness') {
      this.style().thickness = clamp(this.style().thickness + mod, 1, 100)
    } else if (type === 'mirror') {
      this.style().mirror_style = this.style().mirror_style > 2 ? 0 : this.style().mirror_style + 1
    } else {
      console.warn('Unknown', type)
    }
    client.interface.update(true)
    client.renderer.update()
  }
  this.misc = function (type) {
    client.picker.start()
  }
  this.source = function (type) {
    if (type === 'grid') { client.renderer.toggle() }
    if (type === 'open') { client.source.open('grid', client.whenOpen) }
    if (type === 'save') { client.source.write('dotgrid', 'grid', client.tool.export(), 'text/plain') }
    if (type === 'export') { client.source.write('dotgrid', 'svg', client.manager.toString(), 'image/svg+xml') }
    if (type === 'render') { client.manager.toPNG(client.tool.settings.size, (dataUrl) => { client.source.write('dotgrid', 'png', dataUrl, 'image/png') }) }
  }
  this.canAppend = function (content, index = this.index) {
    for (const id in this.layer(index)) {
      const stroke = this.layer(index)[id]
      if (stroke.type !== content.type) { continue }
      if (!stroke.vertices) { continue }
      if (!stroke.vertices[stroke.vertices.length - 1]) { continue }
      if (stroke.vertices[stroke.vertices.length - 1].x !== content.vertices[0].x) { continue }
      if (stroke.vertices[stroke.vertices.length - 1].y !== content.vertices[0].y) { continue }
      return id
    }
    return false
  }
  this.canCast = function (type) {
    if (!type) { return false }
    if (type === 'close') {
      const prev = this.layer()[this.layer().length - 1]
      if (!prev || prev.type === 'close') {
        return false
      }
    }
    if (type === 'bezier') {
      if (this.vertices.length !== 3 && this.vertices.length !== 5 && this.vertices.length !== 7 && this.vertices.length !== 9) {
        return false
      }
    }
    return this.vertices.length >= this.reqs[type]
  }
  this.paths = function () {
    const l1 = new Generator(client.tool.layers[0], client.tool.styles[0]).toString({ x: 0, y: 0 }, 1)
    const l2 = new Generator(client.tool.layers[1], client.tool.styles[1]).toString({ x: 0, y: 0 }, 1)
    const l3 = new Generator(client.tool.layers[2], client.tool.styles[2]).toString({ x: 0, y: 0 }, 1)
    return [l1, l2, l3]
  }
  this.path = function () {
    return new Generator(client.tool.layer(), client.tool.style()).toString({ x: 0, y: 0 }, 1)
  }
  this.translate = function (a, b) {
    for (const segmentId in this.layer()) {
      const segment = this.layer()[segmentId]
      for (const vertexId in segment.vertices) {
        const vertex = segment.vertices[vertexId]
        if (vertex.x === Math.abs(a.x) && vertex.y === Math.abs(a.y)) {
          segment.vertices[vertexId] = { x: Math.abs(b.x), y: Math.abs(b.y) }
        }
      }
    }
    client.history.push(this.layers)
    this.clear()
    client.renderer.update()
  }
  this.translateMulti = function (a, b) {
    const offset = { x: a.x - b.x, y: a.y - b.y }
    const segment = this.selectSegmentAt(a)
    if (!segment) { return }
    for (const vertexId in segment.vertices) {
      const vertex = segment.vertices[vertexId]
      segment.vertices[vertexId] = { x: vertex.x - offset.x, y: vertex.y - offset.y }
    }
    client.history.push(this.layers)
    this.clear()
    client.renderer.update()
  }
  this.translateLayer = function (a, b) {
    const offset = { x: a.x - b.x, y: a.y - b.y }
    for (const segmentId in this.layer()) {
      const segment = this.layer()[segmentId]
      for (const vertexId in segment.vertices) {
        const vertex = segment.vertices[vertexId]
        segment.vertices[vertexId] = { x: vertex.x - offset.x, y: vertex.y - offset.y }
      }
    }
    client.history.push(this.layers)
    this.clear()
    client.renderer.update()
  }
  this.translateCopy = function (a, b) {
    const offset = { x: a.x - b.x, y: a.y - b.y }
    const segment = this.selectSegmentAt(a, copy(this.layer()))
    if (!segment) { return }
    for (const vertexId in segment.vertices) {
      const vertex = segment.vertices[vertexId]
      segment.vertices[vertexId] = { x: vertex.x - offset.x, y: vertex.y - offset.y }
    }
    this.layer().push(segment)
    client.history.push(this.layers)
    this.clear()
    client.renderer.update()
  }
  this.merge = function () {
    const merged = [].concat(this.layers[0]).concat(this.layers[1]).concat(this.layers[2])
    this.erase()
    this.layers[this.index] = merged
    client.history.push(this.layers)
    this.clear()
    client.renderer.update()
  }
  this.style = function () {
    if (!this.styles[this.index]) {
      this.styles[this.index] = []
    }
    return this.styles[this.index]
  }
  this.layer = function (index = this.index) {
    if (!this.layers[index]) {
      this.layers[index] = []
    }
    return this.layers[index]
  }
  this.selectLayer = function (id) {
    this.index = clamp(id, 0, 2)
    this.clear()
    client.renderer.update()
    client.interface.update(true)
    console.log(`layer:${this.index}`)
  }
  this.selectNextLayer = function () {
    this.index = this.index >= 2 ? 0 : this.index++
    this.selectLayer(this.index)
  }
  this.selectPrevLayer = function () {
    this.index = this.index >= 0 ? 2 : this.index--
    this.selectLayer(this.index)
  }
  function copy (data) { return data ? JSON.parse(JSON.stringify(data)) : [] }
  function clamp (v, min, max) { return v < min ? min : v > max ? max : v }
}
      const client = new Client()
      client.install(document.body)
      window.addEventListener('load', () => { 
        client.start()
      })
    </script>
    <style>
* { margin:0;padding:0;border:0;outline:0;text-decoration:none;font-weight:inherit;font-style:inherit;color:inherit;font-size:100%;font-family:inherit;vertical-align:baseline;list-style:none;border-collapse:collapse;border-spacing:0; -webkit-font-smoothing: antialiased;-moz-osx-font-smoothing: grayscale;}
@font-face { font-family: 'input_mono_medium'; font-weight: normal; font-style: normal; font-display: swap; src: url(data:application/font-woff2;charset=utf-8;base64,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) format('woff2'); }
body { padding: 0px; font-family: 'input_mono_medium'; -webkit-user-select: none; overflow: hidden; transition: background-color 500ms; -webkit-app-region: drag; padding: 30px;width:calc(100vw - 60px);height:calc(100vh - 60px)}
#guide { position: absolute;width: 300px;height: 300px; transition: opacity 150ms; -webkit-app-region: no-drag; border-radius: 3px;}
#render { display: none }
#vector { z-index: 1000;position: relative;width:300px; height:300px; }
#interface { font-size: 11px;line-height: 30px;text-transform: uppercase;-webkit-app-region: no-drag; transition: all 150ms; width: 100%; position:fixed; bottom:30px; left:40px; height:30px; max-width:calc(100vw - 75px); overflow: hidden;}
#interface.hidden { bottom:10px !important;opacity: 0 !important }
#interface.visible { bottom:28px !important; opacity: 1 !important}
#interface #menu { opacity: 1; position: absolute; top:0px; transition: all 250ms; z-index: 900; overflow: hidden; height:30px; width:100%;}
#interface #menu svg.icon { width:30px; height:30px; margin-right:-9px; opacity: 0.6; transition: opacity 250ms; }
#interface #menu svg.icon.inactive { opacity: 0.2 }
#interface #menu svg.icon:hover { cursor: pointer; opacity: 1.0 }
#interface #menu svg.icon:last-child { margin-right: 0; }
#interface #menu svg.icon path { fill:none; stroke-linecap: round; stroke-linejoin: round; stroke-width:12px; }
#interface #menu svg.icon.source { float:right; margin-left:-2px; margin-right:0px; }
#interface #menu svg.icon#option_color { opacity: 1.0; z-index:1001; position: relative; }
#interface #menu svg.icon#option_color:hover { opacity: 0.8 }
#interface #picker { position: absolute; line-height: 20px; z-index: 0; width: 30px; opacity: 0; transition: all 250ms; font-size: 11px; border-radius: 3px; left: 200px; top: 0px; text-transform: uppercase; font-family: 'input_mono_medium';height:20px; padding:5px 0px;left:280px; overflow:hidden;}
#interface #picker:before { content:"#"; position: absolute; left:10px; opacity: 0; transition: opacity 500ms}
#interface #picker input { background:transparent; position: absolute; left: 20px; height: 20px; width: 60px; line-height: 20px; opacity: 0; transition: opacity 500ms; text-transform: uppercase;}
#interface #color_path { transition: all 500ms; }
#interface.picker #menu { z-index: 0 }
#interface.picker #picker { width:30px; padding: 5px 15px; padding-right: 45px;  opacity: 1; z-index: 900; width: 50px; left:200px; opacity: 1}
#interface.picker #picker:before { opacity: 1; }
#interface.picker #picker input { opacity: 1 }
#interface.picker #option_thickness { opacity: 0 !important }
#interface.picker #option_mirror { opacity: 0 !important }
#interface.picker #option_fill { opacity: 0 !important }
body.web #interface #menu #option_open { display: none; }
body #guide { opacity: 0; transition: opacity 500ms; }
body.ready #guide { opacity: 1 }
body #interface { opacity: 0; transition: opacity 250ms, bottom 500ms; bottom:15px; }
body.ready #interface { opacity: 1; bottom:30px; }
@media (max-width: 560px) {
  #interface #menu svg.icon.source { opacity: 0; } 
}
body { background:var(--background) !important; }
#picker { background-color:var(--b_inv) !important; color:var(--f_inv) !important; }
#picker:before { color:var(--f_med) !important; }
#picker input::placeholder { color:var(--f_med) !important; }
.fh { color:var(--f_high) !important; stroke:var(--f_high) !important; }
.fm { color:var(--f_med) !important; stroke:var(--f_med) !important; }
.fl { color:var(--f_low) !important; stroke:var(--f_low) !important; }
.f_inv { color:var(--f_inv) !important; stroke:var(--f_inv) !important; }
.bh { background:var(--b_high) !important; }
.bm { background:var(--b_med) !important; }
.bl { background:var(--b_low) !important; }
.b_inv { background:var(--b_inv) !important; }
.icon { color:var(--f_high) !important; stroke:var(--f_high) !important; }
    </style>
  </body>
</html>
